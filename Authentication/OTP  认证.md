# OTP 认证原理

## 一  .  简述



```
OTG 是动态密码 ，每个令牌有不同的ID 与其绑定 ，令牌根据该 ID 和当前 时间 计算出 6位 随机代码 ，服务端 会根据 该 ID 生成随机码 ，如果相同则判断正确, OTP 安全的核心在于密钥 , 每个人通过对应账户生成的密钥是不同的 . 当他们用同一个算法加密时 , 会生成不同的随机密码

```

**1 . 1  分类**

* 时间性 ： 以时间为参数
* 事件性  :   以次数为参数
* 挑战数 ： 以异步挑战数作为参数 ，即服务端下发 挑战码 ，

**1 . 2 常用技术**

```
OTP 类型分为 : 
TOTP（Time-Based One-Time Password，基于时间的一次性密码）
HOTP（HMAC-based One-Time Password，一种基于HMAC的一次性口令算法）
```



## 二 . 算法

### 2.1  TOTP 时间算法

```java
// 计算公式 : OTP(K,C) =Truncate ( HMAC - SHA - 1 ( K , C ) )

K : 密钥串 ，ID
C ：参数
HMAC-SHA-1 ： 使用SHA-1做HMAC
Truncate  ：截取加密后的串，并取加密后串的哪些字段组成一个数字 
    
//  HMAC-SHA-1  模式 
1. HMAC-SHA-1加密后的长度得到一个20字节的密串
2. 取这个20字节的密串的最后一个字节，取这字节的低4位，作为截取加密串的下标偏移量
3. 按照下标偏移量开始，获取4个字节，按照大端方式组成一个整数
4. 截取这个整数的后6位或者8位转成字符串返回  
    
HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
OTP(K,C) = HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
    
    
// TOTP : TOTP只是将其中的参数C变成了由时间戳产生的数字。
C = (T - T0) / X;    
T  :  当前时间戳
T0 :  取值为 0
x :  步数 ，多久参数一个动态密码
```

![](C:\Users\10169\OneDrive\笔记文档\图片文件\协议\TOPT_Algorithm.png)



### 2.2 HTOP

![](C:\Users\10169\OneDrive\笔记文档\图片文件\协议\OTP_algorithm_steps.png)

```java
HTOP 是基于计数器的算法 , 服务端和客户端共用一个密钥 , HOTP 的问题在于怎么保证计数器的同步 , 

对于 HOTP，通过上图我们已经看到输入算法的主要有两个元素，一个是共享密钥，另外一个是计数。在 RFC 算法中用一下字母表示：

K 共享密钥，这个密钥的要求是每个 HOTP 的生成器都必须是唯一的。一般我们都是通过一些随机生成种子的库来实现。
C 计数器，RFC 中把它称为移动元素（moving factor）是一个 8个 byte的数值，而且需要服务器和客户端同步。

另外一个参数比较好理解，

Digit 表示产生的验证码的位数

最后两个参数可能暂时不好理解，我们先放在这，等用到在解释

T 称为限制参数（Throttling Parameter）表示当用户尝试 T 次 OTP 授权后不成功将拒绝该用户的连接。

s 称为重新同步参数（Resynchronization Parameter）表示服务器将通过累加计数器，来尝试多次验证输入的一次性密码，而这个尝试的次数及为 s。该参数主要是有效的容忍用户在客户端无意中生成了额外不用于验证的验证码，导致客户端和服务端不一致，但同时也限制了用户无限制的生成不用于验证的一次性密码。

作者：米车阿里
链接：https://www.jianshu.com/p/a7b900e8e50a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


> 1 服务端的次数落后客户端的次数 , 服务端会匹配多次 , 以达到和客户端同步的次数 ,匹配成功
> 2 服务端超前客户端 , 


// 以下图存在bug , 服务端超前于客户端时,讲不在能验证!!!!!!!!!!!!!
// 解决方案 : 服务器的值应该只能在成功后进行递增 , 只有用户登录成功后 , 才可以更新用户的计数
// 服务端会允许一定次数的计数器 ,但是如果超过限度 , 程序会报错
// 

```

![](C:\Users\10169\OneDrive\笔记文档\图片文件\协议\HOTP_verification_process.png)